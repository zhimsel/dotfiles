#!/usr/bin/env zsh
# vim: foldmethod=marker

# zsh configuration
# written by Zach Himsel, 2014-2016
# https://github.com/zhimsel/dotfiles

# This file is written with vim foldmarkers to enable easier viewing
# It's designed to be viewed/edited from within vim. Each section has
# fold markers at the beginning and end, so you can easily close each
# section to find what you're looking for

# General Settings {{{

umask 077 # set default umask

if [[ -x $(which nvim) ]]; then # set text editor
  export EDITOR="nvim"
else
  export EDITOR="vim"
fi

# $PATH
export PATH="$PATH:/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/bin:/usr/local/sbin"
export PATH="$HOME/bin:$PATH"

# Misc settings
COMPLETION_WAITING_DOTS="true"
DISABLE_UNTRACKED_FILES_DIRTY="true"
HIST_STAMPS="yyyy.mm.dd"
setopt PATH_DIRS
setopt EXTENDED_GLOB
setopt LIST_PACKED
unsetopt CORRECT_ALL
setopt CORRECT
unsetopt AUTO_PUSHD
setopt PUSHD_IGNORE_DUPS
setopt PUSHD_MINUS
setopt EXTENDED_HISTORY
unsetopt AUTO_CD
MAILCHECK=0

# }}}

# Plugins {{{

# Load Oh-My-ZSH and it's plugins
plugins=( \
          adb \
          brew \
          brew-cask \
          command-not-found \
          docker \
          gem \
          git-extras \
          gnu-utils \
          knife \
          nmap \
          osx \
          pip \
          rails \
          rvm \
          screen \
          torrent \
          vagrant \
)
export DISABLE_AUTO_UPDATE="true"
export ZSH=$HOME/.zsh/oh-my-zsh
source $ZSH/oh-my-zsh.sh

# Load normal zsh plugins/RCs
source $HOME/.zsh/opp/opp.zsh
source $HOME/.zsh/opp/opp/*.zsh
source $HOME/.zsh/git-prompt/git-prompt.plugin.zsh
source $HOME/.zsh/completion-generator/zsh-completion-generator.plugin.zsh
source $HOME/.zsh/zsh-autoenv/autoenv.zsh
# }}}

# Autocomplete {{{

# base zsh autocompletion
fpath=(~/.zsh/zsh-completions/src $fpath)
fpath=(~/.zsh/custom-completions $fpath)
autoload -Uz compinit
compinit -u

# bash autocompletions
autoload -Uz bashcompinit
bashcompinit -i
if [ -f ~/.bash_complete ]; then
. ~/.bash_complete
fi

# aws autocompletions
if [ -f "$(which aws_completer)" ]; then
     complete -C $(which aws_completer) aws
fi

# }}}

# Keybinding Settings {{{

# vi mode
bindkey -v
autoload -Uz edit-command-line
bindkey -M vicmd 'v' edit-command-line
export KETTIMEOUT=1
bindkey '^?' backward-delete-char
bindkey '^h' backward-delete-char
bindkey '^w' backward-kill-word
bindkey '^r' history-incremental-search-backward
bindkey -a u undo
bindkey -a '^R' redo
bindkey -sM vicmd '^[' '^G'
bindkey -rM viins '^X'
bindkey -M viins '^X,' _history-complete-newer \
                 '^X/' _history-complete-older \
                 '^X`' _bash_complete-word

# misc keybindings
bindkey -s '^e' 'cd ..\n' #go up a directory with ctrl-e

# }}}

# Aliases {{{

alias s='sudo'
alias please='sudo $(fc -ln -1)'
alias fucking='sudo'
alias la='ls -lah'
alias ltr='ls -ltrh'
alias tree='tree -I .git'
alias h='history'
alias fuck='$(thefuck $(fc -ln -1))'
alias zrcl='vim ~/.zshrc.local'
alias vrcl='vim ~/.vimrc.local'
alias dm='docker-machine'
alias dme='eval $(docker-machine env default)'
alias wtp='git worktree prune -v'
alias wtl='wtp && git worktree list'
alias dockviz="docker run -it --rm -v /var/run/docker.sock:/var/run/docker.sock nate/dockviz"

if [[ -x $(which nvim) ]]; then
  alias vvim=$(which vim)
  alias vim='nvim'
  alias vi='nvim'
fi

# }}}

# Functions {{{

# Make and open new directory
mkcd() { # {{{
  mkdir -p "$1" &&
  eval cd "\"\$$#\""
} # }}}}

# Delete current directory
rmwd() { # {{{
  local current_dir
  current_dir=$(pwd)
  cd .. || exit 1
  rm -rf $current_dir
} # }}}

# Create new blank executable file
xtouch() { # {{{
  touch "$@" &&
  eval chmod +x "$@"
} # }}}

# New cookbook function
newcook() { # {{{
  if [ $1 ] ; then
    git clone git@github.com:zhimsel/skeleton-cookbook.git $1
    cd $1; rm -rf .git/
    egrep -r "skeleton" * .kitchen.yml | cut -d ':' -f 1 | sort | uniq | xargs -n 1 sed -i '' "s/skeleton/$1/g"
  else
    echo "Need the name of the cookbook."
  fi
} # }}}

# Interactive renaming
imv() { # {{{
  local src dst
  for src; do
    [[ -e $src ]] || { print -u2 "$src does not exist"; continue }
    dst=$src
    vared dst
    [[ $src != $dst ]] && mkdir -p $dst:h && mv -n $src $dst
  done
} # }}}

# Create new virtualenvs
mkvenv() { # {{{
  if [[ $1 =~ '[2,3]' ]]; then
    [[ -e .venv ]] || virtualenv -p python${1} .venv
    echo "source \$(dirname \$0)/.venv/bin/activate" > .autoenv.zsh
    echo "deactivate" > .autoenv_leave.zsh
    source .venv/bin/activate
    pip install --upgrade pip neovim ipdb docopt flake8
    echo "Created new virtualenv with $(python -V)"
  else
    echo "Please specify which python version with \"newvenv [2,3]\""
  fi
} # }}}

# Manage git worktrees
wt () { # {{{
  if [[ -z $1 ]]; then
    echo "Please specify the branch to check out"
    return 1
  else
    working_dir="$(pwd)"
    while true; do
      if [[ -f .git ]]; then  # already in a worktree
        cd "$(cat .git | cut -d' ' -f2)/../../.." || return 1
        break
      elif [[ -d .git ]]; then  # in main worktree
        wt_path="../${0:A:h:t}.$1"
        break
      elif [[ "$(pwd)" == '/' ]]; then  # exhausted the whole dir tree
        echo "We don't seem to be in a git worktree"
        cd $working_dir
        return 1
      else  # walk up to the parent dir and try again
        cd ..
        continue
      fi
    done
    git worktree prune
    git branch "$1" &> /dev/null
    wt_add="$(git worktree add "$wt_path" "$1" 2>&1)"
    if [[ $wt_add =~ ^fatal.*already\ checked\ out.* ]]
    then  # if it's already checked out, go there
      cd "$(cut -d\' -f4  <<< "$wt_add")" || return 1
    else  # otherwise, go to the one we just made
      cd "$wt_path" || return 1
    fi
    return 0
  fi
} # }}}
wtr () { # {{{
  working_dir="$(pwd)"
  while true; do
    if [[ -f .git ]]; then
      if [[ "$(git status)" == *clean* ]]; then
        main_wt="$(cat .git | cut -d' ' -f2)/../../.."
        current_wt="${0:A:h}"
        cd "$main_wt" || return 1
        rm -rf "$current_wt" || return 1
        rm -rf "$main_wt/.git/worktrees/${current_wt:t}"
        git worktree prune
        return 0
      else
        echo "Your working directory is not clean! Stash or commit your changes before continuing."
        return 1
      fi
    elif [[ "$(pwd)" == '/' ]]; then
      echo "We don't seem to be in a git worktree"
      cd $working_dir
      return 1
    else
      cd ..
    fi
  done
} # }}}

# cleanup homebrew's cask
cask-clean () { # {{{
  while read cask; do
    caskBasePath="/opt/homebrew-cask/Caskroom"
    local caskDirectory="$caskBasePath/$cask"
    local versionsToRemove="$(ls -vr --color=never $caskDirectory | sed 1,1d)"
    if [[ -n $versionsToRemove ]]; then
        while read versionToRemove ; do
            echo "Removing $cask $versionToRemove..."
            rm -rf "$caskDirectory/$versionToRemove"
        done <<< "$versionsToRemove"
    fi
  done <<< "$(brew cask list)"
} # }}}

# }}}

# Visual/Theme Settings {{{

# set theme
ZSH_THEME=""

# Prompt Settings {{{
ZSH_THEME_GIT_PROMPT_NOCACHE="1"
ZSH_THEME_GIT_PROMPT_BRANCH="%{$fg[magenta]%}"
function precmd {
local user_name="%(!.%{$fg[red]%}.%{$fg[green]%})%n%{$reset_color%}"
local host_name="%{$fg[yellow]%}%m%{$reset_color%}"
local current_dir="%{$fg[blue]%}%~%{$reset_color%}"
local current_time="%{$fg[lightgrey]%}%*%{$reset_color%}"
local git_status="$(if [[ ! -z $GIT_BRANCH ]]; then echo "$(git_super_status) ";fi)"
local return_code="%(?..%{$fg[red]%}â†³ %? %{$reset_color%})"
local command_prompt="%(1j.%(!.%B[%j]%b #.%B[%j]%b $).%(!.#.$))"
local py_venv="$(if [[ ! -z $VIRTUAL_ENV ]]; then echo "(venv) "; fi)"
local vbox_active="$(if [[ ! -z $(ls -H $HOME/.vbox_vms_dir/ 2>/dev/null) ]]; then echo "(vbox) "; fi)"
PROMPT="${return_code}${current_time} ${user_name} at ${host_name} in ${current_dir} ${git_status}${py_venv}${vbox_active}
${command_prompt} "
RPROMPT=""
}
# }}}

# Show a different cursor for different vim modes {{{
function zle-keymap-select zle-line-init
{
    # change cursor shape in iTerm2
    if [[ $TMUX != "" ]]
    then
        case $KEYMAP in
            vicmd)      print -n -- "\033Ptmux;\033\E]50;CursorShape=0\C-G\033\\";;  # block cursor
            viins|main) print -n -- "\033Ptmux;\033\E]50;CursorShape=1\C-G\033\\";;  # line cursor
        esac
    else
        case $KEYMAP in
            vicmd)      print -n -- "\E]50;CursorShape=0\C-G";;  # block cursor
            viins|main) print -n -- "\E]50;CursorShape=1\C-G";;  # line cursor
        esac
    fi

    zle reset-prompt
    zle -R
}

function zle-line-finish
{
    if [[ $TMUX != "" ]]
    then
        print -n -- "\033Ptmux;\033\E]50;CursorShape=0\C-G\033\\"
    else
        print -n -- "\E]50;CursorShape=0\C-G"
    fi
}

zle -N zle-line-init
zle -N zle-line-finish
zle -N zle-keymap-select
# }}}

# }}}

# Credential Agents {{{

# gpg-agent
export GPGKEY=F7D2C279

# ssh-agent {{{
env=~/.ssh/agent.env

agent_is_running() {
    if [ "$SSH_AUTH_SOCK" ]; then
        # ssh-add returns:
        #   0 = agent running, has keys
        #   1 = agent running, no keys
        #   2 = agent not running
        ssh-add -l >/dev/null 2>&1 || [ $? -eq 1 ]
    else
        false
    fi
}

agent_has_keys() {
    ssh-add -l >/dev/null 2>&1
}

agent_load_env() {
    . "$env" >/dev/null
}

agent_start() {
    (umask 077; ssh-agent >"$env")
    . "$env" >/dev/null
}

if ! agent_is_running; then
    agent_load_env
fi

if ! agent_is_running; then
    agent_start
    ssh-add
elif ! agent_has_keys; then
    ssh-add
fi

unset env
# }}}

# }}}

# Local Settings {{{

# load machine-specific options, should always be last to prevent clobbering
if [ -f ~/.zshrc.local ]; then
     source ~/.zshrc.local
fi

# }}}

# Load some stuff that needs to go last {{{

# set up zsh-syntax-highlighting
source ~/.zsh/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh

# set up fzf
if [[ $- == *i* ]]; then
  if [[ -x $HOME/.fzf/fzf ]]; then
    export PATH="$HOME/.fzf/bin:$PATH"
    export MANPATH="$MANPATH:$HOME/.fzf/man"
    export FZF_TMUX=0
    source "$HOME/.fzf/shell/key-bindings.zsh"
    source "$HOME/.fzf/shell/completion.zsh"
   else
     echo "fzf not found. Make sure ~/.fzf is symlinked."
   fi
fi

# terminfo workaround for neovim pane switching issue
# https://github.com/neovim/neovim/issues/2048#issuecomment-78045837
ti_file="$HOME/.terminfo_$TERM.fixed"
touch "$ti_file"
infocmp $TERM | sed 's/kbs=^[hH]/kbs=\\177/' > "$ti_file" || echo "infocomp failed"
tic $ti_file

# }}}
